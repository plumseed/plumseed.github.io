<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/title_favicon_32.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/title_favicon_32.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/title_favicon_16.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">
  <meta name="google-site-verification" content="3dBwV8OlVnNtYzxCLCFp2w8WMpuSecV7vBmA_zrf9j4">
  <meta name="baidu-site-verification" content="eoUZD1BDx6">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":"default"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="本文总结了 C++ 继承中的对象在内存中的布局，对于 C++ 众多特性中不同对象的布局进行深入地详细介绍。">
<meta name="keywords" content="C++,虚函数,内存模型,虚继承">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 对象内存模型详解">
<meta property="og:url" content="https://murphypei.github.io/blog/2017/03/cpp-object-memory-model.html">
<meta property="og:site_name" content="拾荒志">
<meta property="og:description" content="本文总结了 C++ 继承中的对象在内存中的布局，对于 C++ 众多特性中不同对象的布局进行深入地详细介绍。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/virtual_derived.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/base_class.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result1.jpg">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result2.jpg">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/class_members.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/base_class1.jpg">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/object_model1.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result3.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result4.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result5.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/base_class2.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/object_model2.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result6.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/class1.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/object_model3.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result7.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/class2.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/object_model4.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/vtptr_in_class.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/class3.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/object_model5.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result8.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/class4.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/object_model6.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result10.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result11.png">
<meta property="og:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/result12.png">
<meta property="og:updated_time" content="2021-09-06T09:24:43.030Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 对象内存模型详解">
<meta name="twitter:description" content="本文总结了 C++ 继承中的对象在内存中的布局，对于 C++ 众多特性中不同对象的布局进行深入地详细介绍。">
<meta name="twitter:image" content="https://murphypei.github.io/images/posts/cplusplus/object_memory_model/virtual_derived.png">
  <link rel="alternate" href="/atom.xml" title="拾荒志" type="application/atom+xml">
  <link rel="canonical" href="https://murphypei.github.io/blog/2017/03/cpp-object-memory-model">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>C++ 对象内存模型详解 | 拾荒志</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拾荒志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">虚怀若谷，大智若愚</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://murphypei.github.io/blog/2017/03/cpp-object-memory-model.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="murphypei">
      <meta itemprop="description" content="虚怀若谷，大智若愚">
      <meta itemprop="image" content="/images/avatar_128.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒志">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">C++ 对象内存模型详解

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-16T00:00:00+08:00">2017-03-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-06 17:24:43" itemprop="dateModified" datetime="2021-09-06T17:24:43+08:00">2021-09-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>20k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>33 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文总结了 C++ 继承中的对象在内存中的布局，对于 C++ 众多特性中不同对象的布局进行深入地详细介绍。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章较长，而且内容相对来说比较枯燥，希望对 C++ 对象的内存布局、虚表指针、虚基类指针等有深入了解的朋友可以慢慢看。本文的结论都在 VS2013 上得到验证。不同的编译器在内存布局的细节上可能有所不同。文章如果有解释不清、解释不通或疏漏的地方，恳请指出。</p>
<h4 id="何为-C-对象模型？"><a href="#何为-C-对象模型？" class="headerlink" title="何为 C++ 对象模型？"></a>何为 C++ 对象模型？</h4><p>引用《深度探索 C++ 对象模型》这本书中的话：</p>
<blockquote>
<p>有两个概念可以解释 C++ 对象模型：</p>
<ul>
<li>语言中直接支持面向对象程序设计的部分。</li>
<li>对于各种支持的底层实现机制。</li>
</ul>
</blockquote>
<p>直接支持面向对象程序设计，包括了构造函数、析构函数、多态、虚函数等等，这些内容在很多书籍上都有讨论，也是 C++ 最被人熟知的地方（特性）。而对象模型的底层实现机制却是很少有书籍讨论的。对象模型的底层实现机制并未标准化，不同的编译器有一定的自由来设计对象模型的实现细节。在我看来，对象模型研究的是对象在存储上的空间与时间上的更优，并对 C++ 面向对象技术加以支持，如以虚指针、虚表机制支持多态特性。</p>
<h4 id="文章内容简介"><a href="#文章内容简介" class="headerlink" title="文章内容简介"></a>文章内容简介</h4><p>这篇文章主要来讨论 C++ 对象在内存中的布局，属于第二个概念的研究范畴，至于C++ 直接支持面向对象程序设计部分则不多讲。文章主要内容如下：  </p>
<ul>
<li><strong>虚函数表解析：</strong>含有虚函数或其父类含有虚函数的类，编译器都会为其添加一个虚函数表（vtptr）。先了解虚函数表的构成，有助对 C++ 对象模型的理解。</li>
<li><strong>虚基类表解析：</strong>虚继承产生虚基类表（vbptr），虚基类表的内容与虚函数表完全不同，我们将在讲解虚继承时介绍虚继承表。</li>
<li><strong>C++ 对象模型概述：</strong>介绍简单对象模型、表格驱动对象模型，以及非继承情况下的 C++ 对象模型。</li>
<li>继承下的 C++ 对象模型，分析 C++ 类对象在下面情形中的内存布局：<ul>
<li><strong>单继承：</strong>子类单一继承自父类，分析了子类重写父类虚函数、子类定义了新的虚函数情况下子类对象内存布局</li>
<li><strong>多继承：</strong>子类继承于多个父类，分析了子类重写父类虚函数、子类定义了新的虚函数情况下子类对象内存布局，同时分析了非虚继承下的菱形继承。</li>
<li><strong>虚继承：</strong>分析了单一继承下的虚继承、多重基层下的虚继承、重复继承下的虚继承。  </li>
</ul>
</li>
<li>理解对象的内存布局之后，我们可以分析一些问题：<ul>
<li>C++ 封装带来的布局成本是多大？</li>
<li>由空类组成的继承层次中，每个类对象的大小是多大？</li>
</ul>
</li>
</ul>
<p>至于其他与内存有关的知识，我假设大家都有一定的了解，如内存对齐，指针操作等。本文初看可能晦涩难懂，要求读者有一定的 C++ 基础。</p>
<p><strong>注：部分程序截图其中名称错误，以文章内容为准。</strong></p>
<h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><h3 id="多态和虚函数表"><a href="#多态和虚函数表" class="headerlink" title="多态和虚函数表"></a>多态和虚函数表</h3><p>C++ 中<strong>虚函数的作用主要是为了实现多态</strong>机制。多态，简单来说，是指在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive1</span> :</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive2</span> :</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base * ptr1 = <span class="keyword">new</span> Base;</span><br><span class="line">Base * ptr2 = <span class="keyword">new</span> Drive1;</span><br><span class="line">Base * ptr3 = <span class="keyword">new</span> Drive2;</span><br><span class="line"></span><br><span class="line">ptr1-&gt;print();  <span class="comment">//调用Base::print()</span></span><br><span class="line">prt2-&gt;print();  <span class="comment">//调用Drive1::print()</span></span><br><span class="line">prt3-&gt;print();  <span class="comment">//调用Drive2::print()</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/posts/cplusplus/object_memory_model/virtual_derived.png" alt="多态和虚表"></p>
<p>这是一种运行期多态，即父类指针唯有在程序运行时才能知道所指的真正类型是什么。这种运行期决议，是通过虚函数表来实现的。</p>
<h3 id="访问虚函数表"><a href="#访问虚函数表" class="headerlink" title="访问虚函数表"></a>访问虚函数表</h3><p>如果我们丰富我们的 Base 类,使其拥有多个 virtual 函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Base(<span class="keyword">int</span> i) :baseI(i)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了虚函数Base::print()"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用了虚函数Base::setI()"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Base()&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> baseI;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/posts/cplusplus/object_memory_model/base_class.png" alt="使用指针访问虚表"></p>
<p>C++中，当一个类本身定义了虚函数，或其父类有虚函数时，为了支持多态机制，编译器将为该类添加一个<strong>虚函数表指针（vtptr），虚表指针一般都放在对象内存布局的第一个位置上</strong>，这是为了保证在多层继承或多重继承的情况下能以最高效率取到虚函数表。当 vtptr 位于对象内存最前面时，<strong>对象的地址即为虚函数表指针地址</strong>，因此我们可以很容易取得虚函数表指针的地址：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *vtptrAdree = (<span class="keyword">int</span> *)(&amp;b);  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表指针（vtptr）的地址是：\t"</span> &lt;&lt; vtptrAdree &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>我们运行代码出结果：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/result1.jpg" alt>  </p>
<p>我们强行把类对象的地址转换为 <code>int*</code> 类型，取得了虚表指针的地址。<strong>虚表指针指向虚函数表，虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明的顺序一致</strong>。对虚函数表指针取内容值，可以得到虚函数表的指针（vfptr，内存中这个地址存放的就是第一个虚函数的地址），也即是虚函数表中第一个虚函数的地址:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Fun vfunc = (Fun)*((<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个虚函数的地址是："</span> &lt;&lt; (<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"通过地址，调用虚函数Base::print()："</span>;</span><br><span class="line">vfunc();</span><br></pre></td></tr></table></figure>
<ul>
<li>我们把虚表指针的值取出来： <code>*(int*)(&amp;b)</code>，它是一个地址，虚函数表的地址</li>
<li>把虚函数表的地址强制转换成int指针： <code>int* : (int*) *(int*)( &amp;b )</code></li>
<li>再把它转化成我们 <code>Fun</code> 函数指针类型 ： <code>(Fun)*(int*)*(int*)(&amp;b)</code>  </li>
</ul>
<p>注意这里，int 和指针的长度一般都是一样的，所以将地址指针转换为 int 指针。这样，我们就取得了类中的第一个虚函数，我们可以通过函数指针访问它。运行结果：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result2.jpg" alt></p>
<p>同理,第二个虚函数 <code>setI()</code> 的地址为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> *)(*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>同样可以通过函数指针访问它。</p>
<p>目前为止，我们知道了类中虚表指针 vtptr 以及 虚表中虚函数指针 vfptr 的由来，知道了虚函数表中的内容，以及如何通过指针访问虚函数表。下面的文章中将常使用指针访问对象内存来验证我们的 C++ 对象模型，以及讨论在各种继承情况下虚表指针的变化，先把这部分的内容消化完再接着看下面的内容。</p>
<h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++ 对象模型"></a>C++ 对象模型</h2><p>在 C++ 面向对象的类中，有两种数据成员：static 和 non-static，以及三种类成员函数：static、non-static 和 virtual，如下图所示。</p>
<p><img src="/images/posts/cplusplus/object_memory_model/class_members.png" alt></p>
<p>现在我们有一个类 Base，它包含了上面这 5 种类型的数据或函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    Base(<span class="keyword">int</span> i) :baseI(i)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> baseI; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countI</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Base()&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> baseI;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> baseS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/posts/cplusplus/object_memory_model/base_class1.jpg" alt></p>
<p>那么，这个类在内存中将被如何表示？5 种数据都是连续存放的吗？如何布局才能支持 C++ 多态？ 我们的 C++ 标准与编译器将如何塑造出各种数据成员与成员函数呢？我们将分章节进行讨论。</p>
<h2 id="非继承下的对象模型"><a href="#非继承下的对象模型" class="headerlink" title="非继承下的对象模型"></a>非继承下的对象模型</h2><p>概述：在此模型下，non-static 数据成员被置于每一个对象中，而 static 数据成员被置于对象之外。static 与 non-static 函数也都放在对象之外，而对于 virtual 函数，则通过虚函数表和虚指针来支持，具体如下：</p>
<ul>
<li>每个<strong>类</strong>生成一个表格，称为<strong>虚函数表或者虚表</strong>（virtual table，简称 vt）。虚表中存放着一堆指针，这些指针指向该类的每一个虚函数。虚表中的函数地址将按<strong>声明时</strong>的顺序排列（<strong>虚析构函数永远是第一个</strong>），不过当子类有多个重载函数时例外，后面会讨论。</li>
<li>每个<strong>对象</strong>都拥有一个<strong>虚表指针</strong>（vtptr），由编译器为其生成。虚表指针的设定与重置皆由类的复制控制（也即是构造函数、析构函数、赋值操作符）来完成。vtptr 的位置为编译器决定，传统上它被放在所有显示声明的成员之后，不过现在许多<strong>编译器把 vtptr 放在一个对象的在内存中的最前端</strong>。关于数据成员布局的内容，在后面会详细分析。</li>
<li>另外，虚函数表的前面设置了一个指向 <code>type_info</code> 的指针，用以支持 RTTI（Run Time Type Identification，运行时类型识别）。RTTI 是为多态而生成的信息，包括对象继承关系，对象本身的描述等，<strong>只有具有虚函数的对象在会生成，因为是放在虚函数表的前面</strong>。</li>
</ul>
<p>在此模型下，Base 的对象模型如图：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/object_model1.png" alt></p>
<p>先在 VS2013 上验证类对象的布局:</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result3.png" alt></p>
<p>可见对象 b 含有一个 vtptr，并且只有 non-static 数据成员被放置于对象内。我们展开 vt：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result4.png" alt></p>
<p>vt 中有两个指针类型的数据（地址），第一个指向了 Base 类的析构函数，第二个指向了Base的虚函数 <code>print</code>，<strong>顺序与声明顺序相同</strong>。这与上述的 C++ 对象模型相符合。也可以通过代码来进行验证：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBase</span><span class="params">( Base&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"对象的内存起始地址："</span> &lt;&lt; &amp;p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"type_info信息:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    RTTICompleteObjectLocator str = *((RTTICompleteObjectLocator*)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;p) - <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">classname</span><span class="params">(str.pTypeDescriptor-&gt;name)</span></span>;</span><br><span class="line">    classname = classname.substr(<span class="number">4</span>, classname.find(<span class="string">"@@"</span>) - <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="string">"根据type_info信息输出类名:"</span>&lt;&lt; classname &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址:"</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//验证虚表</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表第一个函数的地址："</span> &lt;&lt; (<span class="keyword">int</span> *)*((<span class="keyword">int</span>*)(&amp;p)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数的地址:"</span> &lt;&lt; (<span class="keyword">int</span>* )*(<span class="keyword">int</span> *)*((<span class="keyword">int</span>*)(&amp;p)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表中，第二个虚函数即print（）的地址："</span> &lt;&lt; ((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;p) + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过地址调用虚函数print（）</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    Fun IsPrint=(Fun)* ((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;p) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用了虚函数"</span>；</span><br><span class="line">    IsPrint(); <span class="comment">//若地址正确，则调用了Base类的虚函数print（）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入static函数的地址</span></span><br><span class="line">    p.countI();<span class="comment">//先调用函数以产生一个实例</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"static函数countI()的地址："</span> &lt;&lt; p.countI &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//验证non-static数据成员</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"推测non-static数据成员baseI的地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;p) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"根据推测出的地址，输出该地址的值："</span> &lt;&lt; *((<span class="keyword">int</span> *)(&amp;p) + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::getI():"</span> &lt;&lt; p.getI() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">testBase(b);</span><br></pre></td></tr></table></figure>
<p><img src="/images/posts/cplusplus/object_memory_model/result5.png" alt></p>
<p><strong>结果分析：</strong></p>
<ul>
<li>通过 <code>(int *)(&amp;p)</code> 取得虚函数表的地址。</li>
<li><code>type_info</code> 信息的确存在于虚表的前一个位置。通过<code>((int*)*(int*)(&amp;p) - 1)</code>取得 <code>type_info</code> 信息的指针，并成功获得类的名称的 Base。</li>
<li>虚函数表的第一个函数是析构函数。</li>
<li>虚函数表的第二个函数是虚函数 <code>print</code>，取得地址后通过地址调用它（而非通过对象），验证正确。</li>
<li>对象内存中虚表指针的下一个位置为 non-static 数据成员 <code>baseI</code>。</li>
<li>可以看到，static 成员函数的地址段位与虚表指针、<code>baseI</code> 的地址段位不同。</li>
</ul>
<p>好的，至此我们了解了非继承下类对象五种数据在内存上的布局，也知道了在每一个虚函数表前都有一个指针指向 <code>type_info</code>，负责对 RTTI 的支持。而加入继承后类对象在内存中该如何表示呢？</p>
<h2 id="继承下的对象模型"><a href="#继承下的对象模型" class="headerlink" title="继承下的对象模型"></a>继承下的对象模型</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>在之前的基础上，如果我们定义了派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derive(<span class="keyword">int</span> d) :Base(<span class="number">1000</span>),      DeriveI(d)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//overwrite父类虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Drive::Drive_print()"</span> ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Derive声明的新的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive_print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Drive::Drive_print()"</span> ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Derive()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> DeriveI;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继承类图为：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/base_class2.png" alt></p>
<p>一个派生类如何在机器层面上塑造其父类的实例呢？在 C++ 对象模型中：</p>
<ul>
<li>对于一般继承（这个一般是相对于虚继承而言），若子类重写（overwrite）了父类的虚函数，则<strong>子类虚函数将覆盖虚表中对应的父类虚函数</strong>（注意子类与父类拥有各自的一个虚函数表）；若子类并没有 overwrite 父类虚函数，而是声明了自己新的虚函数，则<strong>该虚函数地址将扩充到虚函数表最后</strong>（在 VS2013 中无法通过监视看到扩充的结果，不过我们通过取地址的方法可以做到，子类新的虚函数确实在虚函数表末端）。</li>
<li>对于虚继承，若子类 overwrite 父类虚函数，同样地将覆盖从父类继承过来的虚函数表中的对应位置，<strong>若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针 vtptr，这与一般继承不同</strong>。  </li>
<li>子类虚析构函数会覆盖掉虚函数表中的分类的虚析构函数。</li>
<li>其实这个图可以表明继承关系中是如何产生类的对象中，我们知道，<strong>C++ 继承时，先调用父类构造函数生成一个父类对象，如图 Base 类实例，然后调用子类的构造函数生成一个子类的对象，其实这个对象在父类的对象上进行扩充</strong>。  </li>
<li>另一方面，子类继承了父类全部的成员，包括 private，只是子类没有访问权限。所以不是没有，是不能访问。</li>
</ul>
<p><img src="/images/posts/cplusplus/object_memory_model/object_model2.png" alt></p>
<p>我们使用代码来验证以上模型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">d</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">    <span class="comment">//[0]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[0]Base::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//vtptr[0]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [0]"</span>;</span><br><span class="line">    Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d)));</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vtptr[1]析构函数无法通过地址调用，故手动输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [1]"</span> &lt;&lt; <span class="string">"Derive::~Derive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vtptr[2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [2]"</span>;</span><br><span class="line">    Fun fun2 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d)) + <span class="number">2</span>);</span><br><span class="line">    fun2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d)) + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[2]Base::baseI="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[2]Derive::DeriveI="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/result6.png" alt></p>
<p>这个结果与我们的对象模型符合。  </p>
<h4 id="继承导致重载函数的隐藏"><a href="#继承导致重载函数的隐藏" class="headerlink" title="继承导致重载函数的隐藏"></a>继承导致重载函数的隐藏</h4><ul>
<li>首先要说明的是，<strong>重载只能发生在同一个类中</strong>，子类和父类之间的同名函数（参数列表），无法构成重载， <strong>子类的同名函数（无论参数列表是否相同），会覆盖所有父类（多继承情况下）的所有同名函数（包括虚函数）</strong>。</li>
<li>因为这种特性，也就导致了子类的同名函数会隐藏父类的重载函数。如果想用父类的重载函数，可以通过 <code>using Base::foo</code> 来声明继承所有的重载函数，然后重写特定参数列表的函数。如果不需要重写，则也可以通过使用父类作用域来显式地调用父类的重载函数。（可以参见《effecive C++》）</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h4 id="一般的多重继承"><a href="#一般的多重继承" class="headerlink" title="一般的多重继承"></a>一般的多重继承</h4><p>单继承中（一般继承），子类会扩展父类的虚函数表。在多继承中，子类含有多个父类的子对象，该往哪个父类的虚函数表扩展呢？当子类 overwrite 了父类的函数，需要覆盖多个父类的虚函数表吗？  </p>
<ul>
<li>子类继承所有父类的虚函数表，因此子类中拥有多个虚函数表指针和虚函数表。</li>
<li>子类的新增的虚函数被放在声明的第一个基类的虚函数表中。</li>
<li>overwrite 时，所有基类的同名函数都被子类的同名函数覆盖。保证了父类指针指向子类对象时，总是能够调用到真正的函数。</li>
<li>内存布局中，父类按照其声明顺序排列。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    Base(<span class="keyword">int</span> i) :baseI(i)&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> baseI; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countI</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> baseI;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> baseS;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base_2(<span class="keyword">int</span> i) :base2I(i)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Base_2()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> base2I; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countI</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base_2::print()"</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> base2I;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> base2S;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive_multyBase</span> :</span><span class="keyword">public</span> Base, <span class="keyword">public</span> Base_2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Drive_multyBase(<span class="keyword">int</span> d) :Base(<span class="number">1000</span>), Base_2(<span class="number">2000</span>) ,Drive_multyBaseI(d)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Drive_multyBase::print"</span> ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Drive_print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Drive_multyBase::Drive_print"</span> ; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Drive_multyBaseI;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继承类图为：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/class1.png" alt></p>
<p>此时 Drive_multyBase 的对象模型是这样的：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/object_model3.png" alt></p>
<p>我们使用代码验证：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Drive_multyBase <span class="title">d</span><span class="params">(<span class="number">3000</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[0]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[0]Base::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//vtptr[0]析构函数无法通过地址调用，故手动输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [0]"</span> &lt;&lt; <span class="string">"Derive::~Derive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vtptr[1]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [1]"</span>;</span><br><span class="line">    Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d))+<span class="number">1</span>);</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d))+<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//vtptr[2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [2]"</span>;</span><br><span class="line">    Fun fun2 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d)) + <span class="number">2</span>);</span><br><span class="line">    fun2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d)) + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[1]Base::baseI="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[2]Base_::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d)+<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//vtptr[0]析构函数无法通过地址调用，故手动输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [0]"</span> &lt;&lt; <span class="string">"Drive_multyBase::~Derive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vtptr[1]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  [1]"</span>;</span><br><span class="line">    Fun fun4 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d))+<span class="number">1</span>);</span><br><span class="line">    fun4();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d))+<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[3]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[3]Base_2::base2I="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[4]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[4]Drive_multyBase::Drive_multyBaseI="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result7.png" alt>  </p>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>菱形继承也称为钻石型继承或重复继承，它指的是基类被某个派生类简单重复继承了多次。这样，派生类对象中拥有多份基类实例（这会带来一些问题）。为了方便叙述，我们不使用上面的代码了，而重新写一个重复继承的继承层次：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/class2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ib;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    B(<span class="keyword">int</span> i=<span class="number">1</span>) :ib(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bf</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::Bf()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ib1;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    B1(<span class="keyword">int</span> i = <span class="number">100</span> ) :ib1(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B1::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B1::f1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bf1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B1::Bf1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ib2;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    B2(<span class="keyword">int</span> i = <span class="number">1000</span>) :ib2(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B2::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B2::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bf2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B2::Bf2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    D(<span class="keyword">int</span> i= <span class="number">10000</span>) :id(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Df</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D::Df()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时，根据单继承，我们可以分析出 B1，B2 类继承于 B 类时的内存布局。又根据一般多继承，我们可以分析出 D 类的内存布局。我们可以得出 D 类子对象的内存布局如下图：  </p>
<p><img src="/images/posts/cplusplus/object_memory_model/object_model4.png" alt></p>
<p>D 类对象内存布局中，图中青色表示 b1 类子对象实例，黄色表示 b2 类子对象实例，灰色表示 D 类子对象实例。从图中可以看到，由于 D 类间接继承了 B 类两次，导致 D 类对象中含有两个 B 类的数据成员 ib，一个属于来源 B1 类，一个来源 B2 类。这样不仅增大了空间，更重要的是引起了程序歧义：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D d;</span><br><span class="line">d.ib =<span class="number">1</span> ;               <span class="comment">//二义性错误,调用的是B1的ib还是B2的ib？</span></span><br><span class="line">d.B1::ib = <span class="number">1</span>;           <span class="comment">//正确</span></span><br><span class="line">d.B2::ib = <span class="number">1</span>;           <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>尽管我们可以通过明确指明调用路径以消除二义性，但二义性的潜在性还没有消除，我们可以通过虚继承来使 D 类只拥有一个 ib 实体。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承解决了菱形继承中最派生类拥有多个间接父类实例的情况。虚继承的派生类的内存布局与普通继承很多不同，主要体现在：</p>
<ul>
<li>虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个虚函数表指针（vtptr）以及一张虚函数表。该 vtptr 位于对象内存最前面（非虚继承则是直接扩展父类虚函数表）。</li>
<li>虚继承的子类也单独<strong>保留了父类的 vtptr 与虚函数表</strong>。这部分内容与子类内容以一个四字节的 0 来分界。<ul>
<li>这两条规则表面，如果虚继承的子类定义了新的虚函数，而且父类中已经有了虚函数，则子类对象中<strong>拥有多个虚表指针</strong>。</li>
</ul>
</li>
<li>虚继承的子类对象中，含有 4 个字节的虚基类表指针偏移值。</li>
</ul>
<p>为了分析最后的菱形继承，我们还是先从单虚继承继承开始。</p>
<h4 id="虚基类表"><a href="#虚基类表" class="headerlink" title="虚基类表"></a>虚基类表</h4><p>在 C++ 对象模型中，虚继承而来的子类会<strong>生成一个隐藏的虚基类指针（vbptr）</strong>，在 Microsoft Visual C++ 中，虚基类表指针总是在虚函数表指针（vtptr）之后，因而，对某个类实例来说，如果它有虚基类指针，那么虚基类指针可能在实例的 0 字节偏移处（该类没有 vtptr 时，vbptr 就处于类实例内存布局的最前面），也可能在类实例的4字节偏移处（有 vtptr）。</p>
<p>虚基类表的一些特性：</p>
<ul>
<li>一个类的虚基类指针指向虚基类表</li>
<li>与虚函数表一样，虚基类表也由多个条目组成，条目中存放的是偏移值。<strong>第一个条目存放虚基类表指针（vbptr）所在地址到该类内存首地址的偏移值</strong>，由第一段的分析我们知道，这个偏移值为 0（类没有 vtptr）或者 -4（类有虚函数，此时有 vtptr）。</li>
<li>虚基类表的第二、第三…个条目依次为<strong>该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值。</strong></li>
</ul>
<p>我们通过一张图来更好地理解。</p>
<p><img src="/images/posts/cplusplus/object_memory_model/vtptr_in_class.png" alt></p>
<h4 id="简单虚继承"><a href="#简单虚继承" class="headerlink" title="简单虚继承"></a>简单虚继承</h4><p>如果我们的 B1 类虚继承于 B 类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的内容与前面相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br></pre></td></tr></table></figure>
<p><img src="/images/posts/cplusplus/object_memory_model/class3.png" alt></p>
<p>根据我们前面对虚继承的派生类的内存布局的分析，B1 类的对象模型应该是这样的：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/object_model5.png" alt></p>
<p><strong>注意上图，子类对象中有两个虚表指针，分别是子类的虚表指针和父类的虚表指针。如果子类重写父类的虚函数，则将父类的虚表中的虚函数地址替换为子类的虚函数地址</strong></p>
<p>我们通过指针访问 B1 类对象的内存，以验证上面的 C++ 对象模型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B1 a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"B1对象内存大小为："</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取得B1的虚函数表</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[0]B1::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;a)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出虚表B1::vtptr中的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">2</span>;++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)(&amp;a) + i);</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址：\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)(&amp;a) + i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[1]vbptr "</span>  ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;a) + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//虚表指针的地址</span></span><br><span class="line">    <span class="comment">//输出虚基类指针条目所指的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">int</span> *)((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;a) + <span class="number">1</span>) + i);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[2]B1::ib1="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;a) + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;a) + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[3]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[3]值="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;a) + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;a) + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[4]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[4]B::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;a) +<span class="number">3</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出B::vtptr中的虚函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;a) + <span class="number">4</span>) + i);</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;a) + <span class="number">4</span>) + i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[5]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[5]B::ib="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;a) + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址: "</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;a) + <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result8.png" alt></p>
<p>这个结果与我们的 C++ 对象模型图完全符合。这时我们可以来分析一下虚表指针的第二个条目值 12 的具体来源了，回忆上文讲到的：</p>
<blockquote>
<p>第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值。</p>
</blockquote>
<p>在我们的例子中，也就是 B 类实例内存地址相对于 vbptr 的偏移值，也即是：[4]-[1]的偏移值，结果即为 12，从地址上也可以计算出来：007CFDFC-007CFDF4 结果的十进制数正是 12。现在，我们对虚基类表的构成应该有了一个更好的理解。</p>
<h4 id="菱形虚继承"><a href="#菱形虚继承" class="headerlink" title="菱形虚继承"></a>菱形虚继承</h4><p>如果我们有如下继承层次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span>  B&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span>  B&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B1,<span class="keyword">public</span> B2&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>类图如下所示：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/class4.png" alt></p>
<p>菱形虚拟继承下，最派生类 D 类的对象模型又有不同的构成了。在D类对象的内存构成上，有以下几点：</p>
<ul>
<li>在 D 类对象内存中，基类出现的顺序是：先是 B1（最左父类），然后是 B2（次左父类），最后是 B（虚祖父类）。</li>
<li>D 类对象的数据成员 id 放在 B 类前面，两部分数据依旧以 0 来分隔。</li>
<li><strong>编译器没有为 D 类生成一个它自己的 vtptr，而是覆盖并扩展了最左父类的虚基类表，与简单继承的对象模型相同</strong>。</li>
<li>超类 B 的内容放到了 D 类对象内存布局的最后。</li>
</ul>
<p>菱形虚拟继承下的C++对象模型为：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/object_model6.png" alt></p>
<p>下面使用代码加以验证：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"D对象内存大小为："</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取得B1的虚函数表</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[0]B1::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出虚表B1::vtptr中的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)(&amp;d) + i);</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址：\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)(&amp;d) + i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[1]B1::vbptr "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//虚表指针的地址</span></span><br><span class="line">    <span class="comment">//输出虚基类指针条目所指的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">int</span> *)((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d) + <span class="number">1</span>) + i);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[2]B1::ib1="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[3]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[3]B2::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出B2::vtptr中的虚函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d) + <span class="number">3</span>) + i);</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d) + <span class="number">3</span>) + i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[4]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[4]B2::vbptr "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">4</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//虚表指针的地址</span></span><br><span class="line">    <span class="comment">//输出虚基类指针条目所指的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">int</span> *)((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d) + <span class="number">4</span>) + i);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[5]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[5]B2::ib2="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址: "</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[6]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[6]D::id="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址: "</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[7]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[7]值="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//间接父类</span></span><br><span class="line">    <span class="comment">//[8]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[8]B::vtptr"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址："</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) + <span class="number">8</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出B::vtptr中的虚函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        Fun fun1 = (Fun)*((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d) + <span class="number">8</span>) + i);</span><br><span class="line">        fun1();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址:\t"</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;d) + <span class="number">8</span>) + i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[9]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[9]B::id="</span> &lt;&lt; *(<span class="keyword">int</span>*)((<span class="keyword">int</span> *)(&amp;d) + <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t地址: "</span> &lt;&lt; (<span class="keyword">int</span> *)(&amp;d) +<span class="number">9</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看运行的结果：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result10.png" alt></p>
<h2 id="内存对象模型的总结"><a href="#内存对象模型的总结" class="headerlink" title="内存对象模型的总结"></a>内存对象模型的总结</h2><h3 id="C-封装带来的布局成本是多大？"><a href="#C-封装带来的布局成本是多大？" class="headerlink" title="C++ 封装带来的布局成本是多大？"></a>C++ 封装带来的布局成本是多大？</h3><p>在 C 语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在 C++ 中，我们通过类来将属性与操作绑定在一起，称为 ADT，抽象数据结构。C 语言中使用 struct（结构体）来封装数据，使用函数来处理数据。举个例子，如果我们定义了一个 struct Point3d 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">&#125; Point3d;</span><br></pre></td></tr></table></figure>
<p>为了打印这个 Point3d，我们可以定义一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point3d_print</span><span class="params">(<span class="keyword">const</span> Point3d *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%f,%f,%f)"</span>,pd-&gt;x,pd-&gt;y,pd_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 C++ 中，我们更倾向于定义一个 Point3d 类，以 ADT 来实现上面的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3d (<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>)</span><br><span class="line">            : _x(x), _y(y), _z(z)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _x;</span><br><span class="line">        <span class="keyword">float</span> _y;</span><br><span class="line">        <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ostream&amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Point3d &amp;pt)</span><br><span class="line">&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">"("</span>&lt;&lt;pr.x()&lt;&lt;<span class="string">","</span></span><br><span class="line">        &lt;&lt;pt.y()&lt;&lt;<span class="string">","</span>&lt;&lt;pt.z()&lt;&lt;<span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这段代码，很多人第一个疑问可能是：加上了封装，布局成本增加了多少？答案是 <strong><code>class Point3d</code> 并没有增加成本</strong>。学过了C++对象模型，我们知道，<strong>Point3d 类对象的内存中，只有三个数据成员</strong>。上面的类声明中，三个数据成员直接内含在每一个 Point3d 对象中，而成员函数虽然在类中声明，却不出现在类对象（object）之中，这些函数（non-inline）属于类而不属于类对象，只会为类产生唯一的函数实例。所以，Point3d 的封装并没有带来任何空间或执行期的效率影响。而在下面这种情况下，C++ 的封装额外成本才会显示出来：</p>
<ul>
<li>虚函数机制（virtual function），用以支持执行期绑定，实现多态。</li>
<li>虚基类（virtual base class），虚继承关系产生虚基类，用于在多重继承下保证基类在子类中拥有唯一实例。</li>
</ul>
<p>不仅如此，Point3d 类数据成员的内存布局与 C 语言的结构体 Point3d 成员内存布局是相同的。C++ 中处在同一个访问标识符（指 public、private、protected）下的声明的数据成员，在内存中必定保证以其声明顺序出现。而处于不同访问标识符声明下的成员则无此规定。对于 Point3d 类来说，它的三个数据成员都处于 private 下，在内存中一起声明顺序出现。我们可以做下实验：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPoint3Member</span><span class="params">(<span class="keyword">const</span> Point3d&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"推测_x的地址是："</span> &lt;&lt; (<span class="keyword">float</span> *) (&amp;p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"推测_y的地址是："</span> &lt;&lt; (<span class="keyword">float</span> *) (&amp;p) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"推测_z的地址是："</span> &lt;&lt; (<span class="keyword">float</span> *) (&amp;p) + <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"根据推测出的地址输出_x的值："</span> &lt;&lt; *((<span class="keyword">float</span> *)(&amp;p)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"根据推测出的地址输出_y的值："</span> &lt;&lt; *((<span class="keyword">float</span> *)(&amp;p)+<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"根据推测出的地址输出_z的值："</span> &lt;&lt; *((<span class="keyword">float</span> *)(&amp;p)+<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function">Point3d <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">TestPoint3Member(a);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result11.png" alt></p>
<p>从结果可以看到，<code>_x</code>，<code>_y</code>，<code>_z</code> 三个数据成员在内存中紧挨着。</p>
<p>总结一下就是：<strong>不考虑虚函数与虚继承，当数据都在同一个访问标识符下，C++ 的类与 C 语言的结构体在对象大小和内存布局上是一致的，C++ 的封装并没有带来空间时间上的影响</strong>。</p>
<h3 id="下面这个空类构成的继承层次中，每个类的大小是多少？"><a href="#下面这个空类构成的继承层次中，每个类的大小是多少？" class="headerlink" title="下面这个空类构成的继承层次中，每个类的大小是多少？"></a>下面这个空类构成的继承层次中，每个类的大小是多少？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span>  B&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span>  B&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    B1 b1;</span><br><span class="line">    B2 b2;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b)="</span> &lt;&lt; <span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b1)="</span> &lt;&lt; <span class="keyword">sizeof</span>(b1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b2)="</span> &lt;&lt; <span class="keyword">sizeof</span>(b2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(d)="</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/images/posts/cplusplus/object_memory_model/result12.png" alt></p>
<p>解析：  </p>
<ul>
<li>编译器为空类安插 1 字节的char，以使该类对象在内存得以配置一个地址。</li>
<li>b1 虚继承于 b，编译器为其安插一个 4 字节的<strong>虚基类表指针（32为机器）</strong>，此时 b1 已不为空，编译器不再为其安插 1 字节的 char（优化）。</li>
<li>d 含有来自 b1 与 b2 两个父类的两个虚基类表指针。大小为 8 字节。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="http://www.cnblogs.com/QG-whz/p/4909359.html" target="_blank" rel="noopener">http://www.cnblogs.com/QG-whz/p/4909359.html</a></li>
</ul>

    </div>

    
    
    
        
      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>murphypei</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://murphypei.github.io/blog/2017/03/cpp-object-memory-model.html" title="C++ 对象内存模型详解">https://murphypei.github.io/blog/2017/03/cpp-object-memory-model.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/C/" rel="tag"># C++</a>
            
              <a href="/tags/虚函数/" rel="tag"># 虚函数</a>
            
              <a href="/tags/内存模型/" rel="tag"># 内存模型</a>
            
              <a href="/tags/虚继承/" rel="tag"># 虚继承</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/blog/2017/02/struct-mnist.html" rel="next" title="Python 操作字节流以及 struct 模块简易教程">
                  <i class="fa fa-chevron-left"></i> Python 操作字节流以及 struct 模块简易教程
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/blog/2017/03/linux-io-multiplexing.html" rel="prev" title="Linux IO 模式及 select、poll、epoll 详解">
                  Linux IO 模式及 select、poll、epoll 详解 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#何为-C-对象模型？"><span class="nav-number">1.0.1.</span> <span class="nav-text">何为 C++ 对象模型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文章内容简介"><span class="nav-number">1.0.2.</span> <span class="nav-text">文章内容简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数表"><span class="nav-number">2.</span> <span class="nav-text">虚函数表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多态和虚函数表"><span class="nav-number">2.1.</span> <span class="nav-text">多态和虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问虚函数表"><span class="nav-number">2.2.</span> <span class="nav-text">访问虚函数表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-对象模型"><span class="nav-number">3.</span> <span class="nav-text">C++ 对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非继承下的对象模型"><span class="nav-number">4.</span> <span class="nav-text">非继承下的对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承下的对象模型"><span class="nav-number">5.</span> <span class="nav-text">继承下的对象模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单继承"><span class="nav-number">5.1.</span> <span class="nav-text">单继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#继承导致重载函数的隐藏"><span class="nav-number">5.1.1.</span> <span class="nav-text">继承导致重载函数的隐藏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多继承"><span class="nav-number">5.2.</span> <span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一般的多重继承"><span class="nav-number">5.2.1.</span> <span class="nav-text">一般的多重继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#菱形继承"><span class="nav-number">5.2.2.</span> <span class="nav-text">菱形继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚继承"><span class="nav-number">5.3.</span> <span class="nav-text">虚继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#虚基类表"><span class="nav-number">5.3.1.</span> <span class="nav-text">虚基类表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单虚继承"><span class="nav-number">5.3.2.</span> <span class="nav-text">简单虚继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#菱形虚继承"><span class="nav-number">5.3.3.</span> <span class="nav-text">菱形虚继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存对象模型的总结"><span class="nav-number">6.</span> <span class="nav-text">内存对象模型的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-封装带来的布局成本是多大？"><span class="nav-number">6.1.</span> <span class="nav-text">C++ 封装带来的布局成本是多大？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下面这个空类构成的继承层次中，每个类的大小是多少？"><span class="nav-number">6.2.</span> <span class="nav-text">下面这个空类构成的继承层次中，每个类的大小是多少？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">6.2.1.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar_128.ico"
      alt="murphypei">
  <p class="site-author-name" itemprop="name">murphypei</p>
  <div class="site-description" itemprop="description">虚怀若谷，大智若愚</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">444</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/murphypei" title="GitHub &rarr; https://github.com/murphypei" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:murphypei47@gmail.com" title="E-Mail &rarr; mailto:murphypei47@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/people/guo-jia-66-80/activities" title="https://www.zhihu.com/people/guo-jia-66-80/activities" rel="noopener" target="_blank">知乎</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">murphypei</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">605k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:49</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>





















  

  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'e14928c5d4e586a1be33',
      clientSecret: 'b58488475e69824177de7fa4e52325a0de1dbdb7',
      repo: 'murphypei.github.io',
      owner: 'murphypei',
      admin: ['murphypei'],
      id: '0c5c869f1a6fcf1e3dcdbcd9d885bf9f',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haru01.model.json"},"display":{"position":"left","width":250,"height":400},"mobile":{"show":false}});</script></body>
</html>
